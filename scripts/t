#!/usr/bin/env -S uv run --script

# /// script
# dependencies = [
#   "pydantic",
#   "rich"
# ]
# ///

from argparse import ArgumentParser
from pathlib import Path
from pydantic import BaseModel, Field
from enum import IntEnum, auto
from typing import Optional, Protocol
import json
from contextlib import contextmanager
import subprocess
import uuid
import curses
from dataclasses import dataclass, field as DCField
from collections import defaultdict

from rich import print

class Window:
    def __init__(self):
        self.screen = None

    def initialize(self):
        self.screen = curses.initscr()

        curses.noecho()
        curses.cbreak()

        try:
            curses.start_color()
            curses.use_default_colors()
        except:
            pass

        self.screen.keypad(1)

        curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
        curses.init_pair(2, curses.COLOR_YELLOW, curses.COLOR_BLACK)
        curses.init_pair(3, curses.COLOR_GREEN, curses.COLOR_BLACK)

    def reset(self):
        if self.screen is None:
            return

        self.screen.keypad(0)
        curses.echo()
        curses.nocbreak()
        curses.endwin()
        self.screen = None

    def run_terminal_app(self, *args: str, input: Optional[str]=None):
        self.reset()
        res = subprocess.run(*args, input=input, text=True, stdout=subprocess.PIPE)
        self.initialize()
        return res


@contextmanager
def window_manager():
    window = Window()
    window.initialize()
    try:
        yield window
    finally:
        window.reset()


def pick(options: list[str]) -> Optional[str]:
    res = subprocess.run("fzf", input="\n".join(options), stdout=subprocess.PIPE, text=True)
    try:
        res.check_returncode()
    except Exception:
        return None

    return res.stdout.strip()


TIMEFRAME_OPTIONS = ["d", "w", "m", "q", "y", "5y"]

class Timeframe(IntEnum):
    day = 0
    week = auto()
    month = auto()
    quarter = auto()
    year = auto()
    five_year = auto()

    @staticmethod
    def from_str(val: str) -> "Timeframe":
        return Timeframe(TIMEFRAME_OPTIONS.index(val))

    def to_s(self):
        return TIMEFRAME_OPTIONS[self.value]

class PriorityTable(BaseModel):
    a: Optional[str] = None
    b1: Optional[str] = None
    b2: Optional[str] = None
    c1: Optional[str] = None
    c2: Optional[str] = None


    def set_a(self, id: str):
        self.a = id

    def set_b(self, id: str):
        self.b2 = self.b1
        self.b1 = id

    def set_c(self, id: str):
        self.c2 = self.c1
        self.c1 = id


class Task(BaseModel):
    title: str
    description: Optional[str] = None
    project_id: Optional[str] = None
    timeframe: Optional[Timeframe] = None


class Project(BaseModel):
    tasks: set[str]
    title: str
    parents: set[str]
    timeframe: Timeframe
    description: Optional[str] = None

    def delete(self, root: Path):
        (root / f"{id}.md").unlink(missing_ok=True)
        if (root / f"{id}").is_dir():
            (root / f"{id}").rmdir()


class Collection(BaseModel):
    tasks: dict[str, Task]
    projects: dict[str, Project]
    source_dir: Path = Field(exclude=True)

    # Acting on projects
    five_year_prios: PriorityTable
    yearly_prios: PriorityTable
    quarterly_prios: PriorityTable
    monthly_prios: PriorityTable
    weekly_prios: PriorityTable

    # Acting on tasks
    daily_prios: PriorityTable

    current_timeframe: Timeframe = Timeframe.five_year

    def current_prios(self):
        if self.current_timeframe == Timeframe.five_year:
            return self.five_year_prios

        if self.current_timeframe == Timeframe.year:
            return self.yearly_prios

        if self.current_timeframe == Timeframe.quarter:
            return self.quarterly_prios

        if self.current_timeframe == Timeframe.month:
            return self.monthly_prios

        if self.current_timeframe == Timeframe.week:
            return self.weekly_prios

        assert False

    def is_prio_a(self, pid: str):
        p = self.projects[pid]
        assert p.timeframe != Timeframe.day
        for tbl in [
            self.five_year_prios,
            self.yearly_prios,
            self.quarterly_prios,
            self.monthly_prios,
            self.weekly_prios
        ]:
            if tbl.a == pid:
                return True
        return False

    def is_prio_b(self, pid: str):
        p = self.projects[pid]
        assert p.timeframe != Timeframe.day
        for tbl in [
            self.five_year_prios,
            self.yearly_prios,
            self.quarterly_prios,
            self.monthly_prios,
            self.weekly_prios
        ]:
            if tbl.b1 == pid or tbl.b2 == pid:
                return True
        return False


    def is_prio_c(self, pid: str):
        p = self.projects[pid]
        assert p.timeframe != Timeframe.day
        for tbl in [
            self.five_year_prios,
            self.yearly_prios,
            self.quarterly_prios,
            self.monthly_prios,
            self.weekly_prios
        ]:
            if tbl.c1 == pid or tbl.c2 == pid:
                return True
        return False


    @staticmethod
    def load(path: Path):
        if not (path / "tasks.json").is_file():
            return Collection(tasks={}, projects={}, source_dir=path)

        with (path / "tasks.json").open("r") as f:
            collection = Collection(**json.load(f), source_dir=path)
            collection.validate()
            return collection

    def save(self):
        with (self.source_dir / "tasks.json").open("w") as f:
            f.write(self.model_dump_json(indent=4))

    def validate(self):
        for task in self.tasks.values():
            assert task.project_id is None or task.project_id in self.projects

        for project in self.projects.values():
            for task in project.tasks:
                assert task in self.tasks
                assert self.tasks[task].timeframe is None or self.tasks[task].timeframe <= project.timeframe

            for parent in project.parents:
                assert parent in self.projects
                assert self.projects[parent].timeframe > project.timeframe


@contextmanager
def collection():
    collection = Collection.load(Path.home() / "notes/buckets")
    yield collection
    collection.save()


def review(args):
    """
    - review timeframe
    - for each open element say "delete", "defer", "complete"
    - view notes of previous time frame
    - add note
    """

    pass


def plan(args):
    """
    - plan timeframe
    - add new projects
    - set priority
    """
    pass


def show(args):
    """
    - view current projects as tree-view
    """

    def print_task(c: Collection, tid: str):
        t = c.tasks[tid]
        timeframe = None
        if t.timeframe is not None:
            timeframe = t.timeframe.to_s()
        elif t.project_id is not None:
            timeframe = c.projects[t.project_id].timeframe.to_s()

        pid = t.project_id or "orphaned"
        if timeframe is not None:
            timeframe = ":" + timeframe

        color = "bright_black"
        if tid == c.daily_prios.a:
            color = "red"
        elif tid == c.daily_prios.b1 or tid == c.daily_prios.b2:
            color = "yellow"
        elif tid == c.daily_prios.c1 or tid == c.daily_prios.c2:
            color = "green"

        print(f"[{color}]\[{pid}{timeframe or ''}] {t.title}[/{color}]")

    def print_project(c: Collection, pid: str):
        color = "bright_black"
        if c.is_prio_a(pid):
            color = "red"
        elif c.is_prio_b(pid):
            color = "yellow"
        elif c.is_prio_c(pid):
            color = "green"

        p = c.projects[pid]
        print(f"[{color}]\[{pid}:{p.timeframe.to_s()}] {p.title}[/{color}]")

    with collection() as c:
        def sorted_task_index(tid: str):
            assert tid in c.tasks
            t = c.tasks[tid]
            if t.timeframe is not None:
                return t.timeframe

            if t.project_id is not None:
                return c.projects[t.project_id].timeframe

            return -1

        sorted_task_ids = sorted(c.tasks, key=sorted_task_index)
        sorted_empty_projects = sorted(c.projects, key=lambda pid: c.projects[pid].timeframe)
        print("--- Tasks --- ")
        for tid in sorted_task_ids:
            print_task(c, tid)

        print()
        print("--- Projects --- ")
        for pid in sorted_empty_projects:
            print_project(c, pid)


def add_project(c: Collection, id: str):
    print("Adding project")
    title = input("Title: ").strip()
    description = input("Description: ").strip()
    timeframe = Timeframe.from_str(input("Timeframe: ").strip())
    parent = None
    possible_parents = [pid for pid, p in c.projects.items() if p.timeframe > timeframe]
    if len(possible_parents) > 0:
        possible_parents.append("<create new>")
        use_parent = input("Set Parent? [Y/n]:").strip().lower()
        if len(use_parent) == 0 or use_parent == "y":
            parent = pick(possible_parents)
        else:
            assert use_parent == "n"

        if parent == "<create new>":
            new_id = input("Parent id: ").strip()
            add_project(c, new_id)
            parent = new_id

    assert id not in c.projects
    c.projects[id] = Project(
        tasks=set(),
        title=title,
        description=description,
        parents=set(),
        timeframe=timeframe
    )

    print("Added project")

    for tid, t in c.tasks.items():
        if t.project_id == id:
            c.projects[id].tasks.add(tid)
            print("Linked orphaned task")

def add_proj(args):
    with collection() as c:
        try:
            add_project(c, args.id)
        except KeyboardInterrupt:
            pass


def add(args):
    with collection() as c:
        id = str(uuid.uuid4())
        while id in c.tasks:
            id = str(uuid.uuid4())

        if args.parent is not None:
            assert args.parent in c.projects
            c.projects[args.parent].tasks.add(id)

        timeframe = None if args.timeframe is None else Timeframe.from_str(args.timeframe)

        c.tasks[id] = Task(title=args.title, 
                           description=args.description, 
                           project_id=args.parent,
                           timeframe=timeframe)


def create_parsers() -> ArgumentParser:
    parser = ArgumentParser("A file-based project manager")
    subparsers = parser.add_subparsers()

    add_parser = subparsers.add_parser("add", help="Create a new task")
    add_parser.add_argument("title", help="The task title")
    add_parser.add_argument("-d", "--description", help="The task description")
    add_parser.add_argument("-p", "--parent", help="The project for this task")
    add_parser.add_argument("-t", "--timeframe", help="The timeframe for this task")
    add_parser.set_defaults(func=add)

    add_parser = subparsers.add_parser("add-proj")
    add_parser.add_argument("id", help="The project id")
    add_parser.set_defaults(func=add_proj)

    show_parser = subparsers.add_parser("show")
    show_parser.add_argument("id", help="The project id", nargs="?")
    show_parser.set_defaults(func=show)

    return parser


@dataclass
class ProjectPreviewTable:
    columns: list[list[Optional[str]]] = DCField(default_factory=list)
    selected_x: int = 1
    selected_y: int = 0

    @staticmethod
    def from_collection(c: Collection):
        @dataclass
        class ProjectsRow:
            prio_a: Optional[str] = None
            prio_bs: list[str] = DCField(default_factory=list)
            prio_cs: list[str] = DCField(default_factory=list)
            other: list[str] = DCField(default_factory=list)

            def insert(self, pid: str, c: Collection):
                if c.is_prio_a(pid):
                    self.prio_a = pid
                elif c.is_prio_b(pid):
                    self.prio_bs.append(pid)
                elif c.is_prio_c(pid):
                    self.prio_cs.append(pid)
                else:
                    self.other.append(pid)

            def __iter__(self):
                if self.prio_a is not None:
                    yield self.prio_a

                yield from self.prio_bs
                yield from self.prio_cs
                yield from self.other


        rows = defaultdict(ProjectsRow)

        for pid, p in c.projects.items():
            rows[p.timeframe].insert(pid, c)

        def project_titles(timeframe):
            return [c.projects[pid].title for pid in rows[timeframe]]

        rows = [
            ["Next Five Years: "] + project_titles(Timeframe.five_year),
            ["This Year:"] + project_titles(Timeframe.year),
            ["This Quarter:"] + project_titles(Timeframe.quarter),
            ["This Month:"] + project_titles(Timeframe.month),
            ["This Week:"] + project_titles(Timeframe.week),
            ["Today:"] + project_titles(Timeframe.day),
        ]

        columns = []
        for row in rows:
            while len(columns) < len(row):
                columns.append([])
            for i, elem in enumerate(row):
                columns[i].append(elem)
        return ProjectPreviewTable(columns)

    def width(self):
        return 0 if len(self.columns) == 0 else len(self.columns[0])

    def height(self):
        return len(self.columns)

    def render(self, w):
        start = 0
        for x, col in enumerate(self.columns):
            max_width = 0
            for y, elem in enumerate(col):
                attr = 0
                if x == self.selected_x and y == self.selected_y:
                    attr = curses.A_REVERSE
                w.screen.addstr(y, start, elem, attr)
                max_width = max(max_width, len(elem))
            start += max_width + 1


class WindowMode(Protocol):
    def render_main_window(self, w: Window, c: Collection):
        pass

    def handle_input(self, ch: str, c: Collection) -> Optional["WindowMode"]:
        pass

    def available_commands(self, c: Collection):
        yield from ()


class PlanningMode(WindowMode):
    def __init__(self, c: Collection):
        self.index = 0
        self.project_ids = [
            pid for pid, p in c.projects.items() if p.timeframe == c.current_timeframe
        ]
        self.selecting_priority = False

    def render_main_window(self, w: Window, c: Collection):
        for i, pid in enumerate(self.project_ids):
            attr = 0
            if c.is_prio_a(pid):
                attr = curses.color_pair(1)
            elif c.is_prio_b(pid):
                attr = curses.color_pair(2)
            elif c.is_prio_c(pid):
                attr = curses.color_pair(3)

            if i == self.index:
                attr = attr | curses.A_REVERSE
            w.screen.addstr(i, 0, f"{pid}: {c.projects[pid].title}", attr)

    def handle_input(self, ch: str, c: Collection) -> Optional[WindowMode]:
        if self.selecting_priority:
            if ch.lower() == "a":
                c.current_prios().set_a(self.project_ids[self.index])

            if ch.lower() == "b":
                c.current_prios().set_b(self.project_ids[self.index])

            if ch.lower() == "c":
                c.current_prios().set_c(self.project_ids[self.index])

            self.selecting_priority = False
            return None

        if ch.lower() == "p":
            self.selecting_priority = True
            return None

        if ch == "KEY_UP" or ch.lower() == "k":
            self.index -= 1

        if ch == "KEY_DOWN" or ch.lower() == "j":
            self.index += 1

        if self.index < 0:
            self.index = 0
        if self.index >= len(self.project_ids):
            self.index = len(self.project_ids) - 1

    def available_commands(self, c: Collection):
        if self.selecting_priority:
            yield "a", "A"
            yield "b", "B"
            yield "c", "C"
            return

        yield "c", "Create new project"
        yield "d", "Delete project"
        yield "p", "Set priority"


class MainWindow(WindowMode):
    def __init__(self, c: Collection):
        self.table = ProjectPreviewTable.from_collection(c)

    def render_main_window(self, w: Window, c: Collection):
        self.table.render(w)

    def handle_input(self, ch: str, c: Collection) -> Optional[WindowMode]:
        if ch.lower() == "r":
            pass
        elif ch.lower() == "p":
            return PlanningMode(c)

        if ch == "KEY_RIGHT" or ch.lower() == "l":
            self.table.selected_x += 1

        if ch == "KEY_LEFT" or ch.lower() == "h":
            self.table.selected_x -= 1

        if ch == "KEY_UP" or ch.lower() == "k":
            self.table.selected_y -= 1

        if ch == "KEY_DOWN" or ch.lower() == "j":
            self.table.selected_y += 1

        self.table.selected_x = (self.table.selected_x + self.table.width()) % self.table.width()
        if self.table.selected_x == 0:
            self.table.selected_x = 1
        self.table.selected_y = (self.table.selected_y + self.table.height()) % self.table.height()

        return None

    def available_commands(self, c):
        if c.current_timeframe != Timeframe.five_year:
            yield "r", f"Review {c.current_timeframe.to_s()}"

        if c.current_timeframe != Timeframe.day:
            yield "p", f"Plan {c.current_timeframe.to_s()}"


def win_main(w: Window, c: Collection):
    state = MainWindow(c)

    while True:
        w.screen.clear()
        state.render_main_window(w, c)

        commands = { 
            "q": "Quit",
        }

        for cmd, name in state.available_commands(c):
            assert cmd not in commands
            commands[cmd] = name

        command_bar_str = ""
        for key, name in commands.items():
            command_bar_str += f"({key}) {name}  "

        w.screen.subwin(curses.LINES-3, 0).box()
        w.screen.addstr(curses.LINES-2, 1, command_bar_str)
        w.screen.refresh()

        ch = w.screen.getkey()
        if ch.lower() == "q":
            break

        new_state = state.handle_input(ch, c)
        if new_state is not None:
            state = new_state


def main():
    args = create_parsers().parse_args()

    func = None
    try:
        func = args.func
    except AttributeError:
        with window_manager() as w:
            with collection() as c:
                win_main(w, c)
        return
    func(args)

if __name__ == '__main__':
    main()
