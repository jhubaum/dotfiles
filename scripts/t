#!/usr/bin/env -S uv run --script

# /// script
# dependencies = [
#   "pydantic",
#   "rich"
# ]
# ///

from argparse import ArgumentParser
from pathlib import Path
from pydantic import BaseModel, Field
from enum import IntEnum, auto
from typing import Any, Optional, Protocol
import json
from contextlib import contextmanager
import subprocess
import uuid
import curses
from dataclasses import dataclass, field as DCField
from collections import defaultdict
import sys
import tempfile
import os

from rich import print

CONTEXT = {
    "private": Path.home() / "notes/buckets",
    "work": Path.home() / "gtd"
}

METADATA_FILE = Path.home() / ".taskstate.json"

class Window:
    def __init__(self):
        self.screen = None

    def initialize(self):
        self.screen = curses.initscr()

        curses.noecho()
        curses.cbreak()
        curses.curs_set(0)

        try:
            curses.start_color()
            curses.use_default_colors()
        except:
            pass

        self.screen.keypad(1)

        curses.init_pair(1, curses.COLOR_RED, -1)
        curses.init_pair(2, curses.COLOR_YELLOW, -1)
        curses.init_pair(3, curses.COLOR_GREEN, -1)
        curses.init_pair(4, 8, -1)

    def reset(self):
        if self.screen is None:
            return

        self.screen.keypad(0)
        curses.echo()
        curses.nocbreak()
        curses.endwin()
        self.screen = None


def write_with_editor(w: Window, prompt: str) -> Optional[str]:
    fd, path = tempfile.mkstemp()
    os.close(fd)
    with open(path, "w") as f:
        f.write(prompt)

    mtime = os.path.getmtime(path)

    w.reset()

    try:
        subprocess.run(["nvim", path]).check_returncode()
    finally:
        w.initialize()

    new_mtime = os.path.getmtime(path)
    if mtime == new_mtime:
        return None


    text = None
    with open(path, 'r') as f:
        text = f.read()
        if text.startswith(prompt):
            text = text[len(prompt):]

    os.remove(path)
    return text


@contextmanager
def window_manager():
    window = Window()
    window.initialize()
    try:
        yield window
    finally:
        window.reset()


def pick(options: list[str]) -> Optional[str]:
    res = subprocess.run("fzf", input="\n".join(options), stdout=subprocess.PIPE, text=True)
    try:
        res.check_returncode()
    except Exception:
        return None

    return res.stdout.strip()


TIMEFRAME_OPTIONS = ["d", "w", "m", "q", "y", "5y"]

class Timeframe(IntEnum):
    day = 0
    week = auto()
    month = auto()
    quarter = auto()
    year = auto()
    five_year = auto()

    def downwards(self, until):
        it = self
        while it.value > until.value:
            yield it
            it = it.smaller()

    def smaller(self):
        assert self != Timeframe.day
        return Timeframe(self.value - 1)

    def bigger(self):
        assert self != Timeframe.five_year
        return Timeframe(self.value + 1)

    @staticmethod
    def from_str(val: str) -> "Timeframe":
        return Timeframe(TIMEFRAME_OPTIONS.index(val))

    def to_s(self):
        return TIMEFRAME_OPTIONS[self.value]

class PriorityTable(BaseModel):
    a: Optional[str] = None
    b1: Optional[str] = None
    b2: Optional[str] = None
    c1: Optional[str] = None
    c2: Optional[str] = None


    def set_a(self, id: str):
        self.reset(id)
        self.a = id

    def set_b(self, id: str):
        self.reset(id)
        self.b2 = self.b1
        self.b1 = id

    def set_c(self, id: str):
        self.reset(id)
        self.c2 = self.c1
        self.c1 = id

    def reset(self, id: str):
        if self.a == id:
            self.a = None

        if self.b1 == id:
            self.b1 = self.b2
            self.b2 = None

        if self.b2 == id:
            self.b2 = None

        if self.c1 == id:
            self.c1 = self.c2
            self.c2 = None

        if self.c2 == id:
            self.c2 = None


class Task(BaseModel):
    title: str
    description: Optional[str] = None
    project_id: Optional[str] = None
    timeframe: Optional[Timeframe] = None


class Project(BaseModel):
    tasks: set[str]
    title: str
    parents: set[str]
    timeframe: Timeframe
    description: Optional[str] = None

    def delete(self, root: Path):
        (root / f"{id}.md").unlink(missing_ok=True)
        if (root / f"{id}").is_dir():
            (root / f"{id}").rmdir()


class Collection(BaseModel):
    tasks: dict[str, Task]
    projects: dict[str, Project]
    context: str = Field(exclude=True)

    # Acting on projects
    five_year_prios: PriorityTable = PriorityTable()
    yearly_prios: PriorityTable = PriorityTable()
    quarterly_prios: PriorityTable = PriorityTable()
    monthly_prios: PriorityTable = PriorityTable()
    weekly_prios: PriorityTable = PriorityTable()

    # Acting on tasks
    daily_prios: PriorityTable = PriorityTable()

    current_timeframe: Timeframe = Timeframe.five_year
    current_plans: dict[Timeframe, str] = Field(default_factory=dict)

    def current_prios(self):
        if self.current_timeframe == Timeframe.five_year:
            return self.five_year_prios

        if self.current_timeframe == Timeframe.year:
            return self.yearly_prios

        if self.current_timeframe == Timeframe.quarter:
            return self.quarterly_prios

        if self.current_timeframe == Timeframe.month:
            return self.monthly_prios

        if self.current_timeframe == Timeframe.week:
            return self.weekly_prios

        assert False

    def is_prio_a(self, pid: str):
        p = self.projects[pid]
        assert p.timeframe != Timeframe.day
        for tbl in [
            self.five_year_prios,
            self.yearly_prios,
            self.quarterly_prios,
            self.monthly_prios,
            self.weekly_prios
        ]:
            if tbl.a == pid:
                return True
        return False

    def is_prio_b(self, pid: str):
        p = self.projects[pid]
        assert p.timeframe != Timeframe.day
        for tbl in [
            self.five_year_prios,
            self.yearly_prios,
            self.quarterly_prios,
            self.monthly_prios,
            self.weekly_prios
        ]:
            if tbl.b1 == pid or tbl.b2 == pid:
                return True
        return False


    def is_prio_c(self, pid: str):
        p = self.projects[pid]
        assert p.timeframe != Timeframe.day
        for tbl in [
            self.five_year_prios,
            self.yearly_prios,
            self.quarterly_prios,
            self.monthly_prios,
            self.weekly_prios
        ]:
            if tbl.c1 == pid or tbl.c2 == pid:
                return True
        return False


    @staticmethod
    def load(context=None):
        if context is None:
            if METADATA_FILE.is_file():
                context = json.loads(METADATA_FILE.read_text())["current_context"]
            else:
                context = "private"

        path = CONTEXT[context]
        if not (path / "tasks.json").is_file():
            return Collection(tasks={}, projects={}, context=context)

        with (path / "tasks.json").open("r") as f:
            collection = Collection(**json.load(f), context=context)
            collection.validate()
            return collection

    def save(self):
        with (CONTEXT[self.context] / "tasks.json").open("w") as f:
            f.write(self.model_dump_json(indent=4))

        with METADATA_FILE.open("w") as f:
            json.dump(dict(current_context=self.context), f, ensure_ascii=False, indent=4)

    def validate(self):
        # TODO: Turn this into proper errors
        # Also, create a dialog to fix these errors if they appear
        # Right now, the tool doesn't start and I have to manually edit the tasks.json
        # to resolve these errors
        for task in self.tasks.values():
            assert task.project_id is None or task.project_id in self.projects

        for file in CONTEXT[self.context].iterdir():
            if file.is_file() and file.name != "tasks.json":
                assert file.suffix == ".md", file
                assert file.stem in self.projects, f"Orphaned file {file.name}"
            if file.is_dir():
                assert file.name in self.projects, f"Orphaned directory {file.name}"

        for project in self.projects.values():
            for task in project.tasks:
                assert task in self.tasks
                assert self.tasks[task].timeframe is None or self.tasks[task].timeframe <= project.timeframe

            for parent in project.parents:
                assert parent in self.projects
                assert self.projects[parent].timeframe > project.timeframe


@contextmanager
def collection():
    collection = Collection.load()
    yield collection
    collection.save()


def review(args):
    """
    - review timeframe
    - for each open element say "delete", "defer", "complete"
    - view notes of previous time frame
    - add note
    """

    pass


def plan(args):
    """
    - plan timeframe
    - add new projects
    - set priority
    """
    pass


def show(args):
    """
    - view current projects as tree-view
    """

    def print_task(c: Collection, tid: str):
        t = c.tasks[tid]
        timeframe = None
        if t.timeframe is not None:
            timeframe = t.timeframe.to_s()
        elif t.project_id is not None:
            timeframe = c.projects[t.project_id].timeframe.to_s()

        pid = t.project_id or "orphaned"
        if timeframe is not None:
            timeframe = ":" + timeframe

        color = "bright_black"
        if tid == c.daily_prios.a:
            color = "red"
        elif tid == c.daily_prios.b1 or tid == c.daily_prios.b2:
            color = "yellow"
        elif tid == c.daily_prios.c1 or tid == c.daily_prios.c2:
            color = "green"

        print(f"[{color}]\[{pid}{timeframe or ''}] {t.title}[/{color}]")

    def print_project(c: Collection, pid: str):
        color = "bright_black"
        if c.is_prio_a(pid):
            color = "red"
        elif c.is_prio_b(pid):
            color = "yellow"
        elif c.is_prio_c(pid):
            color = "green"

        p = c.projects[pid]
        print(f"[{color}]\[{pid}:{p.timeframe.to_s()}] {p.title}[/{color}]")

    with collection() as c:
        def sorted_task_index(tid: str):
            assert tid in c.tasks
            t = c.tasks[tid]
            if t.timeframe is not None:
                return t.timeframe

            if t.project_id is not None:
                return c.projects[t.project_id].timeframe

            return -1

        sorted_task_ids = sorted(c.tasks, key=sorted_task_index)
        sorted_empty_projects = sorted(c.projects, key=lambda pid: c.projects[pid].timeframe)
        print("--- Tasks --- ")
        for tid in sorted_task_ids:
            print_task(c, tid)

        print()
        print("--- Projects --- ")
        for pid in sorted_empty_projects:
            print_project(c, pid)


def add_project(c: Collection, id: str):
    print("Adding project")
    title = input("Title: ").strip()
    description = input("Description: ").strip()
    timeframe = Timeframe.from_str(input("Timeframe: ").strip())
    parent = None
    possible_parents = [pid for pid, p in c.projects.items() if p.timeframe > timeframe]
    if len(possible_parents) > 0:
        possible_parents.append("<create new>")
        use_parent = input("Set Parent? [Y/n]:").strip().lower()
        if len(use_parent) == 0 or use_parent == "y":
            parent = pick(possible_parents)
        else:
            assert use_parent == "n"

        if parent == "<create new>":
            new_id = input("Parent id: ").strip()
            add_project(c, new_id)
            parent = new_id

    assert id not in c.projects
    c.projects[id] = Project(
        tasks=set(),
        title=title,
        description=description,
        parents=set(),
        timeframe=timeframe
    )

    print("Added project")

    for tid, t in c.tasks.items():
        if t.project_id == id:
            c.projects[id].tasks.add(tid)
            print("Linked orphaned task")

def add_proj(args):
    with collection() as c:
        try:
            add_project(c, args.id)
        except KeyboardInterrupt:
            pass


def add(args):
    with collection() as c:
        id = str(uuid.uuid4())
        while id in c.tasks:
            id = str(uuid.uuid4())

        if args.parent is not None:
            assert args.parent in c.projects
            c.projects[args.parent].tasks.add(id)

        timeframe = None if args.timeframe is None else Timeframe.from_str(args.timeframe)

        c.tasks[id] = Task(title=args.title, 
                           description=args.description, 
                           project_id=args.parent,
                           timeframe=timeframe)


def create_parsers() -> ArgumentParser:
    parser = ArgumentParser("A file-based project manager")
    subparsers = parser.add_subparsers()

    add_parser = subparsers.add_parser("add", help="Create a new task")
    add_parser.add_argument("title", help="The task title")
    add_parser.add_argument("-d", "--description", help="The task description")
    add_parser.add_argument("-p", "--parent", help="The project for this task")
    add_parser.add_argument("-t", "--timeframe", help="The timeframe for this task")
    add_parser.set_defaults(func=add)

    add_parser = subparsers.add_parser("add-proj")
    add_parser.add_argument("id", help="The project id")
    add_parser.set_defaults(func=add_proj)

    show_parser = subparsers.add_parser("show")
    show_parser.add_argument("id", help="The project id", nargs="?")
    show_parser.set_defaults(func=show)

    return parser

@dataclass
class RenderElement:
    content: str
    attr: int = 0

def render_rows(w: Window, index: int, labels: list[RenderElement], rows: list[list[RenderElement]], width: int):
    assert len(labels) == len(rows)

    label_length = max(len(label.content) for label in labels)

    col_widths = []

    for row in rows:
        for i, elem in enumerate(row):
            if len(col_widths) <= i:
                col_widths.append(len(elem.content))
            else:
                col_widths[i] = max(col_widths[i], len(elem.content))

    for i, label in enumerate(labels):
        w.screen.addstr(i, 0, label.content, label.attr)
        w.screen.addstr(i, label_length, ":")

    if len(col_widths) == 0:
        return

    minimal_width = col_widths[index] + label_length + 2
    while index > 0 and minimal_width + col_widths[index-1] + 1 < width:
        index -= 1
        minimal_width += col_widths[index] + 1


    for i, row in enumerate(rows):
        start = label_length + 2

        if index != 0:
            w.screen.addstr(i, start, "... ")
            start += 4

        for j, elem in enumerate(row[index:]):
            remaining_space = width - start

            if remaining_space < 3:
                if remaining_space > 0:
                    w.screen.addstr(i, start, "." * remaining_space)
                break

            if remaining_space < len(elem.content):
                elem.content = elem.content[0:remaining_space-3] + "..."

            w.screen.addstr(i, start, elem.content, elem.attr)
            start += col_widths[j+index] + 1


@dataclass
class ProjectPreviewTable:
    project_id_rows: list[list[str]] 
    selected_x: int = 0
    selected_y: int = 0

    @staticmethod
    def from_collection(c: Collection):
        @dataclass
        class ProjectsRow:
            prio_a: Optional[str] = None
            prio_bs: list[str] = DCField(default_factory=list)
            prio_cs: list[str] = DCField(default_factory=list)
            other: list[str] = DCField(default_factory=list)

            def insert(self, pid: str, c: Collection):
                if c.is_prio_a(pid):
                    self.prio_a = pid
                elif c.is_prio_b(pid):
                    self.prio_bs.append(pid)
                elif c.is_prio_c(pid):
                    self.prio_cs.append(pid)
                else:
                    self.other.append(pid)

            def __iter__(self):
                if self.prio_a is not None:
                    yield self.prio_a

                yield from self.prio_bs
                yield from self.prio_cs
                yield from self.other


        rows = defaultdict(ProjectsRow)
        for pid, p in c.projects.items():
            rows[p.timeframe].insert(pid, c)

        return ProjectPreviewTable(project_id_rows=[ 
            list(rows[Timeframe.five_year]),
            list(rows[Timeframe.year]),
            list(rows[Timeframe.quarter]),
            list(rows[Timeframe.month]),
            list(rows[Timeframe.week]),
            list(rows[Timeframe.day]),
        ])

    def render(self, w, c, width):
        # TODO: I could just render the labels manually here and pass on a different x coordinate as a starting point
        # for the rows. That would make this initialisation a bit easier, I'd think
        def highlight_timeframe(c, t):
            return curses.A_REVERSE if c.current_timeframe == t else 0

        labels = [
            RenderElement(content="Next Five Years ", attr=highlight_timeframe(c, Timeframe.five_year)),
            RenderElement(content="This Year", attr=highlight_timeframe(c, Timeframe.year)),
            RenderElement(content="This Quarter", attr=highlight_timeframe(c, Timeframe.quarter)),
            RenderElement(content="This Month", attr=highlight_timeframe(c, Timeframe.month)),
            RenderElement(content="This Week", attr=highlight_timeframe(c, Timeframe.week)),
            RenderElement(content="Today", attr=highlight_timeframe(c, Timeframe.day))
        ]

        rows = []
        for i, l in enumerate(labels):
            row = []
            selected_x = min(self.selected_x, len(self.project_id_rows[i])-1)
            for j, pid in enumerate(self.project_id_rows[i]):
                attr = None
                if c.is_prio_a(pid):
                    attr = curses.color_pair(1)
                elif c.is_prio_b(pid):
                    attr = curses.color_pair(2)
                elif c.is_prio_c(pid):
                    attr = curses.color_pair(3)

                if self.selected_y == i and selected_x == j:
                    if attr is None:
                        attr = 0
                    attr |= curses.A_REVERSE

                if attr is None:
                    attr = curses.color_pair(4)
                row.append(RenderElement(content=c.projects[pid].title, attr=attr))
            rows.append(row)
        render_rows(w, self.selected_x, labels, rows, width)

    def width(self):
        return max(len(row) for row in self.project_id_rows)

    def height(self):
        return len(self.project_id_rows)


    def selected(self):
        if len(self.project_id_rows[self.selected_y]) == 0:
            return None
        return self.project_id_rows[self.selected_y][min(self.selected_x, len(self.project_id_rows[self.selected_y])-1)]


def render_project_preview(w: Window, c: Collection, pid: str, width):
    scr = w.screen.subwin(curses.LINES-3, width, 0, curses.COLS - width)
    scr.box()

    p = c.projects[pid]
    h = 1

    def add_str(string, attr=0):
        nonlocal h
        scr.addstr(h, 1, string, attr);
        h += 1

    add_str(p.title, curses.A_BOLD)
    if p.description is not None and len(p.description) > 0:
        h += 1
        add_str(p.description)

    child_projects = set()
    for cid, child in c.projects.items():
        # TODO: Do this recursively to detect all child projects
        if pid in child.parents:
            child_projects.add(cid)

    if len(child_projects) > 0:
        h += 1
        add_str("Projects")
        for cid in child_projects:
            child = c.projects[cid]
            add_str(f"- [{cid}:{child.timeframe.to_s()}] {child.title}")

    if len(p.tasks) > 0:
        h += 1
        add_str("Tasks")
        for tid in p.tasks:
            add_str(f"- [ ] {c.tasks[tid].title}")

    attachment_dir = CONTEXT[c.context] / pid
    if attachment_dir.is_dir():
        add_str("Attachments", curses.A_BOLD)
        for file in attachment_dir.iterdir():
            add_str(f"- {file.relative_to(attachment_dir)}")

    project_file = CONTEXT[c.context] / f"{pid}.md"
    if project_file.is_file():
        with project_file.open() as f:
            for line in f.readlines():
                add_str(line)
                if h > curses.LINES-5: # Why 5? Stop using so many constants when layouting in new version
                    break


class WindowMode(Protocol):
    def render_main_window(self, w: Window, c: Collection):
        pass

    def handle_input(self, ch: str, w: Window, c: Collection) -> Optional["WindowMode"]:
        pass

    def available_commands(self, c: Collection):
        yield from ()

@dataclass
class FormField:
    name: str
    value: Optional[str] = None
    editable: bool = True

@dataclass
class ProjectCreateScreen:
    scr: Any
    timeframe: Timeframe
    fields: list[FormField]
    selected_field_index: Optional[int] = 0
    selected_menu_index: Optional[int] = None

    @staticmethod
    def create(w: Window, c: Collection):
        return ProjectCreateScreen(
            scr=w.screen.subwin(curses.LINES // 3, curses.COLS // 3, curses.LINES // 3, curses.COLS // 3),
            fields=[
                FormField(name="id"),
                FormField(name="name"),
                FormField(name="description"),
                FormField(name="timeframe", value=c.current_timeframe.name, editable=False)
            ],
            timeframe=c.current_timeframe
        )

    def render(self):
        self.scr.clear()
        self.scr.box()

        self.scr.addstr(0, 1, "Create new project")

        def highlight_if_eq(a, b):
            return curses.A_REVERSE if a == b else 0

        for i, field in enumerate(self.fields):
            self.scr.addstr(2+i, 2, field.name)
            self.scr.addstr(2+i, 14, ":")
            if field.value is not None:
                self.scr.addstr(2+i, 16, field.value, highlight_if_eq(self.selected_field_index, i))
            else:
                self.scr.addstr(2+i, 16, "_" * 16, highlight_if_eq(self.selected_field_index, i))

        self.scr.addstr(curses.LINES // 3 - 3, 5, "<cancel>", highlight_if_eq(self.selected_menu_index, 0))
        self.scr.addstr(curses.LINES // 3 - 3, 15, "<create>", highlight_if_eq(self.selected_menu_index, 1))


    def handle_input(self, w: Window, ch: str):
        if self.selected_field_index is not None:
            if ch == "KEY_UP" or ch.lower() == "k":
                self.selected_field_index -= 1
                if self.selected_field_index < 0:
                    self.selected_field_index = 0

            if ch == "KEY_DOWN" or ch.lower() == "j":
                self.selected_field_index += 1
                while not self.fields[self.selected_field_index].editable:
                    self.selected_field_index += 1
                    if self.selected_field_index >= len(self.fields):
                        self.selected_field_index = None
                        self.selected_menu_index = 1
                        break

            if ch == "\n":
                f = self.fields[self.selected_field_index]
                if f.value is None:
                    f.value = ""

                self.scr.move(2+self.selected_field_index, 16 + len(f.value))
                curses.curs_set(1)
                self.scr.refresh()
                sys.stdout.write("\033[4 q")
                sys.stdout.flush()

                key = w.screen.getkey()
                while key != "\n":
                    if key == "\b" or key == "\x7f":
                        self.scr.addch(2+self.selected_field_index, 16 + len(f.value), " ", 0)
                        f.value = f.value[0:-1]
                    elif key == "\x1b": # Escape
                        # TODO: Reset inserted value
                        break
                    else:
                        # TODO: Actually handle escape sequences here, similar to what textpad.TextBox does
                        assert key.isalnum() or key == " " or key == "-", f"Encountered invalid key {repr(key)}"
                        self.scr.addch(2+self.selected_field_index, 16 + len(f.value), key, 0)
                        f.value += key

                    self.scr.refresh()
                    key = w.screen.getkey()

                sys.stdout.write("\033[0 q")
                sys.stdout.flush()
                curses.curs_set(1)
                self.scr.refresh()

        if self.selected_menu_index is not None:
            if ch == "KEY_UP" or ch.lower() == "k":
                self.selected_menu_index = None
                self.selected_field_index = len(self.fields) -1
                while not self.fields[self.selected_field_index].editable:
                    self.selected_field_index -= 1

            if ch == "KEY_RIGHT" or ch.lower() == "l":
                self.selected_menu_index = 1

            if ch == "KEY_LEFT" or ch.lower() == "h":
                self.selected_menu_index = 0


            if ch == "\n":
                if self.selected_menu_index == 0:
                    return True, None, None
                assert self.selected_menu_index == 1
                return True, self.fields[0].value, Project(
                    tasks=set(),
                    title=self.fields[1].value,
                    description=self.fields[2].value,
                    parents=set(),
                    timeframe=self.timeframe
                )
        return False, None, None


class PlanningMode(WindowMode):
    def __init__(self, c: Collection):
        self.index = 0
        self.project_ids = [
            pid for pid, p in c.projects.items() if p.timeframe == c.current_timeframe
        ]
        self.selecting_priority = False
        self.create_scr = None

    def render_main_window(self, w: Window, c: Collection):
        h = 0
        for tf in Timeframe.five_year.downwards(until=c.current_timeframe):
            w.screen.addstr(h, 0, f"Plan ({tf.to_s()}): {c.current_plans[tf].strip()}")
            h += 1

        h += 1

        for i, pid in enumerate(self.project_ids):
            attr = 0
            if c.is_prio_a(pid):
                attr = curses.color_pair(1)
            elif c.is_prio_b(pid):
                attr = curses.color_pair(2)
            elif c.is_prio_c(pid):
                attr = curses.color_pair(3)

            if i == self.index:
                attr = attr | curses.A_REVERSE
            w.screen.addstr(i+h, 0, f"{pid}: {c.projects[pid].title}", attr)
        if len(self.project_ids) > 0:
            render_project_preview(w, c, self.project_ids[self.index], curses.COLS // 2)

        if self.create_scr is not None:
            self.create_scr.render()

    def handle_input(self, ch: str, w: Window, c: Collection) -> Optional[WindowMode]:
        if self.create_scr is not None:
            done, pid, proj = self.create_scr.handle_input(w, ch)
            if done:
                self.create_scr = None
            if pid is not None:
                assert proj is not None
                assert pid not in c.projects
                c.projects[pid] = proj
                self.project_ids.append(pid)
            return None

        if self.selecting_priority:
            if ch.lower() == "a":
                c.current_prios().set_a(self.project_ids[self.index])

            if ch.lower() == "b":
                c.current_prios().set_b(self.project_ids[self.index])

            if ch.lower() == "c":
                c.current_prios().set_c(self.project_ids[self.index])

            if ch.lower() == "r":
                c.current_prios().reset(self.project_ids[self.index])

            self.selecting_priority = False
            return None

        if ch.lower() == "e":
            raise NotImplementedError("Editing projects is not implemented yet")

        if ch.lower() == "c":
            # TODO: Should I use the panels API here?
            self.create_scr = ProjectCreateScreen.create(w, c)

        if ch.lower() == "f":
            # TODO: THis should probably be its own window state
            # For this, we probably need a stack of window states so we know where we need to return to
            commit_message = write_with_editor(w, f"[{c.context}] Commit to {c.current_timeframe.to_s()} plan\n")
            if commit_message is not None:
                c.current_plans[c.current_timeframe] = commit_message
                c.current_timeframe = c.current_timeframe.smaller()
                return MainWindow(c)


        if ch.lower() == "p":
            self.selecting_priority = True
            return None

        if ch == "KEY_UP" or ch.lower() == "k":
            self.index -= 1

        if ch == "KEY_DOWN" or ch.lower() == "j":
            self.index += 1

        if self.index < 0:
            self.index = 0
        if self.index >= len(self.project_ids):
            self.index = len(self.project_ids) - 1

    def available_commands(self, c: Collection):
        if self.selecting_priority:
            yield "a", "A"
            yield "b", "B"
            yield "c", "C"
            yield "r", "reset"
            return

        yield "c", "Create new project"
        yield "e", "Edit project"
        yield "d", "Delete project"
        yield "p", "Set priority"
        yield "f", "Finish Plan"


class MainWindow(WindowMode):
    def __init__(self, c: Collection):
        self.table = ProjectPreviewTable.from_collection(c)
        self.show_project_overview = False

    def render_main_window(self, w: Window, c: Collection):
        width = curses.COLS
        if self.show_project_overview:
            width = curses.COLS // 2
        self.table.render(w, c, width)
        pid = self.table.selected()
        if pid is not None and self.show_project_overview:
            render_project_preview(w, c, pid, width)

    def handle_input(self, ch: str, w: Window, c: Collection) -> Optional[WindowMode]:
        if ch.lower() == "r":
            pass
        elif ch.lower() == "p":
            return PlanningMode(c)

        if ch == "\t":
            self.show_project_overview = not self.show_project_overview

        if ch == "KEY_RIGHT" or ch.lower() == "l":
            self.table.selected_x += 1

        if ch == "KEY_LEFT" or ch.lower() == "h":
            self.table.selected_x -= 1

        if ch == "KEY_UP" or ch.lower() == "k":
            self.table.selected_y -= 1

        if ch == "KEY_DOWN" or ch.lower() == "j":
            self.table.selected_y += 1

        self.table.selected_y = max(0, min(self.table.selected_y, self.table.height()))
        self.table.selected_x = max(0, min(self.table.selected_x, len(self.table.project_id_rows[self.table.selected_y])))

        return None

    def available_commands(self, c):
        yield "\t", "Toggle project preview"
        if c.current_timeframe != Timeframe.five_year:
            yield "r", f"Review {c.current_timeframe.bigger().to_s()}"

        if c.current_timeframe != Timeframe.day:
            yield "p", f"Plan {c.current_timeframe.to_s()}"


def win_main(w: Window):
    collection = Collection.load()
    state = MainWindow(collection)

    SPECIAL_KEYS = { "\t": "TAB" }

    while True:
        w.screen.clear()
        state.render_main_window(w, collection)

        commands = { 
            "q": "Quit"
        }

        # TODO: Is there a better way to do this check?
        if isinstance(state, MainWindow):
            commands["c"] = "Switch Context"

        for cmd, name in state.available_commands(collection):
            assert cmd not in commands
            commands[cmd] = name

        command_bar_str = f"[{collection.context}]  "
        for key, name in commands.items():
            if key in SPECIAL_KEYS:
                key = f"<{SPECIAL_KEYS[key]}>"
            else:
                key = f"({key})"
            command_bar_str += f"{key} {name}  "

        w.screen.subwin(curses.LINES-3, 0).box()
        w.screen.addstr(curses.LINES-2, 1, command_bar_str)
        w.screen.refresh()

        ch = w.screen.getkey()

        w.screen.refresh()
        if ch.lower() == "q":
            break
        # I need to check if we're in main window because the planning window
        # uses (c) for creating a new project
        # TODO: Create a better connection between commands and their keybindings
        if ch.lower() == "c" and isinstance(state, MainWindow):
            if collection.context == "private":
                new_context = "work"
            else:
                new_context = "private"
            collection.save()
            collection = Collection.load(new_context)
            state = MainWindow(collection)
            continue

        new_state = state.handle_input(ch, w, collection)
        if new_state is not None:
            state = new_state


    collection.save()


def main():
    args = create_parsers().parse_args()

    func = None
    try:
        func = args.func
    except AttributeError:
        with window_manager() as w:
            win_main(w)
        return
    func(args)

if __name__ == '__main__':
    main()
