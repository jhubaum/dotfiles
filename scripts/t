#!/usr/bin/env -S uv run --script

# /// script
# dependencies = [
#   "pydantic"
# ]
# ///

from argparse import ArgumentParser
from pathlib import Path
from pydantic import BaseModel, Field
from enum import IntEnum, auto
from typing import Optional
import json
from contextlib import contextmanager
import subprocess
import uuid

TIMEFRAME_OPTIONS = ["d", "w", "m", "q", "y", "5y"]


def pick(options: list[str]) -> Optional[str]:
    res = subprocess.run("fzf", input="\n".join(options), stdout=subprocess.PIPE, text=True)
    try:
        res.check_returncode()
    except Exception:
        return None

    return res.stdout.strip()


class Timeframe(IntEnum):
    day = 0
    week = auto()
    month = auto()
    quarter = auto()
    year = auto()
    five_year = auto()

    @staticmethod
    def from_str(val: str) -> "Timeframe":
        return Timeframe(TIMEFRAME_OPTIONS.index(val))


class Task(BaseModel):
    title: str
    description: Optional[str] = None
    project_id: Optional[str] = None
    timeframe: Optional[Timeframe] = None


class Project(BaseModel):
    tasks: set[str]
    title: str
    description: Optional[str] = None
    parents: set[str]
    timeframe: Timeframe

    def delete(self, root: Path):
        (root / f"{id}.md").unlink(missing_ok=True)
        if (root / f"{id}").is_dir():
            (root / f"{id}").rmdir()


class Collection(BaseModel):
    tasks: dict[str, Task]
    projects: dict[str, Project]
    source_dir: Path = Field(exclude=True)

    @staticmethod
    def load(path: Path):
        if not (path / "tasks.json").is_file():
            return Collection(tasks={}, projects={}, source_dir=path)

        with (path / "tasks.json").open("r") as f:
            collection = Collection(**json.load(f), source_dir=path)
            collection.validate()
            return collection

    def save(self):
        with (self.source_dir / "tasks.json").open("w") as f:
            f.write(self.model_dump_json(indent=4))

    def validate(self):
        for task in self.tasks.values():
            assert task.project_id is None or task.project_id in self.projects

        for project in self.projects.values():
            for task in project.tasks:
                assert task in self.tasks
                assert self.tasks[task].timeframe is None or self.tasks[task].timeframe <= project.timeframe

            for parent in project.parents:
                assert parent in self.projects
                assert self.projects[parent].timeframe > project.timeframe


@contextmanager
def collection():
    collection = Collection.load(Path.home() / "notes/buckets")
    yield collection
    collection.save()


def review(args):
    """
    - review timeframe
    - for each open element say "delete", "defer", "complete"
    - view notes of previous time frame
    - add note
    """

    pass


def plan(args):
    """
    - plan timeframe
    - add new projects
    - set priority
    """
    pass


def show(args):
    """
    - view current projects as tree-view
    """
    with collection() as c:
        for pid, p in c.projects.items():
            print(p.timeframe, f"{pid}: {p.title}")
        for t in c.tasks.values():
            print(t.title)


def add_project(c: Collection, id: str):
    print("Adding project")
    title = input("Title: ").strip()
    description = input("Description: ").strip()
    timeframe = Timeframe.from_str(input("Timeframe: ").strip())
    parent = None
    possible_parents = [pid for pid, p in c.projects.items() if p.timeframe > timeframe]
    if len(possible_parents) > 0:
        possible_parents.append("<create new>")
        use_parent = input("Set Parent? [Y/n]:").strip().lower()
        if len(use_parent) == 0 or use_parent == "y":
            parent = pick(possible_parents)
        else:
            assert use_parent == "n"

        if parent == "<create new>":
            new_id = input("Parent id: ").strip()
            add_project(c, new_id)
            parent = new_id

    assert id not in c.projects
    c.projects[id] = Project(
        tasks=set(),
        title=title,
        description=description,
        parents=set(),
        timeframe=timeframe
    )

    print("Added project")

    for tid, t in c.tasks.items():
        if t.project_id == id:
            c.projects[id].tasks.add(tid)
            print("Linked orphaned task")

def add_proj(args):
    with collection() as c:
        try:
            add_project(c, args.id)
        except KeyboardInterrupt:
            pass


def add(args):
    with collection() as c:
        id = str(uuid.uuid4())
        while id in c.tasks:
            id = str(uuid.uuid4())

        if args.parent is not None:
            assert args.parent in c.projects
            c.projects[args.parent].tasks.add(id)

        timeframe = None if args.timeframe is None else Timeframe.from_str(args.timeframe)

        c.tasks[id] = Task(title=args.title, 
                           description=args.description, 
                           project_id=args.parent,
                           timeframe=timeframe)


def create_parsers() -> ArgumentParser:
    parser = ArgumentParser("A file-based project manager")
    subparsers = parser.add_subparsers()

    add_parser = subparsers.add_parser("add", help="Create a new task")
    add_parser.add_argument("title", help="The task title")
    add_parser.add_argument("-d", "--description", help="The task description")
    add_parser.add_argument("-p", "--parent", help="The project for this task")
    add_parser.add_argument("-t", "--timeframe", help="The timeframe for this task")
    add_parser.set_defaults(func=add)

    add_parser = subparsers.add_parser("add-proj")
    add_parser.add_argument("id", help="The project id")
    add_parser.set_defaults(func=add_proj)

    show_parser = subparsers.add_parser("show")
    show_parser.add_argument("id", help="The project id", nargs="?")
    show_parser.set_defaults(func=show)

    return parser


def main():
    args = create_parsers().parse_args()

    func = None
    try:
        func = args.func
    except AttributeError:
        create_parsers().print_usage()
        exit(1)
    func(args)


if __name__ == '__main__':
    main()
