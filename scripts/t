#!/usr/bin/env -S uv run --script

# /// script
# dependencies = [
#   "pydantic",
#   "rich"
# ]
# ///

from argparse import ArgumentParser
from pathlib import Path
from pydantic import BaseModel, Field
from enum import IntEnum, auto
from typing import Optional
import json
from contextlib import contextmanager
import subprocess
import uuid



def pick(options: list[str]) -> Optional[str]:
    res = subprocess.run("fzf", input="\n".join(options), stdout=subprocess.PIPE, text=True)
    try:
        res.check_returncode()
    except Exception:
        return None

    return res.stdout.strip()


TIMEFRAME_OPTIONS = ["d", "w", "m", "q", "y", "5y"]

class Timeframe(IntEnum):
    day = 0
    week = auto()
    month = auto()
    quarter = auto()
    year = auto()
    five_year = auto()

    @staticmethod
    def from_str(val: str) -> "Timeframe":
        return Timeframe(TIMEFRAME_OPTIONS.index(val))

    def to_s(self):
        return TIMEFRAME_OPTIONS[self.value]


class Task(BaseModel):
    title: str
    description: Optional[str] = None
    project_id: Optional[str] = None
    timeframe: Optional[Timeframe] = None


class Project(BaseModel):
    tasks: set[str]
    title: str
    description: Optional[str] = None
    parents: set[str]
    timeframe: Timeframe

    def delete(self, root: Path):
        (root / f"{id}.md").unlink(missing_ok=True)
        if (root / f"{id}").is_dir():
            (root / f"{id}").rmdir()


class Collection(BaseModel):
    tasks: dict[str, Task]
    projects: dict[str, Project]
    source_dir: Path = Field(exclude=True)

    task_prio_a: Optional[str] = None
    task_prio_b1: Optional[str] = None
    task_prio_b2: Optional[str] = None
    task_prio_c1: Optional[str] = None
    task_prio_c2: Optional[str] = None

    proj_prio_a: Optional[str] = None
    proj_prio_b1: Optional[str] = None
    proj_prio_b2: Optional[str] = None
    proj_prio_c1: Optional[str] = None
    proj_prio_c2: Optional[str] = None

    @staticmethod
    def load(path: Path):
        if not (path / "tasks.json").is_file():
            return Collection(tasks={}, projects={}, source_dir=path)

        with (path / "tasks.json").open("r") as f:
            collection = Collection(**json.load(f), source_dir=path)
            collection.validate()
            return collection

    def save(self):
        with (self.source_dir / "tasks.json").open("w") as f:
            f.write(self.model_dump_json(indent=4))

    def validate(self):
        for task in self.tasks.values():
            assert task.project_id is None or task.project_id in self.projects

        for project in self.projects.values():
            for task in project.tasks:
                assert task in self.tasks
                assert self.tasks[task].timeframe is None or self.tasks[task].timeframe <= project.timeframe

            for parent in project.parents:
                assert parent in self.projects
                assert self.projects[parent].timeframe > project.timeframe


@contextmanager
def collection():
    collection = Collection.load(Path.home() / "notes/buckets")
    yield collection
    collection.save()


def review(args):
    """
    - review timeframe
    - for each open element say "delete", "defer", "complete"
    - view notes of previous time frame
    - add note
    """

    pass


def plan(args):
    """
    - plan timeframe
    - add new projects
    - set priority
    """
    pass


def show(args):
    """
    - view current projects as tree-view
    """

    def print_task(c: Collection, tid: str):
        t = c.tasks[tid]
        timeframe = None
        if t.timeframe is not None:
            timeframe = t.timeframe.to_s()
        elif t.project_id is not None:
            timeframe = c.projects[t.project_id].timeframe.to_s()

        pid = t.project_id or "orphaned"
        if timeframe is not None:
            timeframe = ":" + timeframe

        color = "bright_black"
        if tid == c.task_prio_a:
            color = "red"
        elif tid == c.task_prio_b1 or tid == c.task_prio_b2:
            color = "yellow"
        elif tid == c.task_prio_c1 or tid == c.task_prio_c2:
            color = "green"

        print(f"[{color}]\[{pid}{timeframe or ''}] {t.title}[/{color}]")

    def print_project(c: Collection, pid: str):
        color = "bright_black"
        if pid == c.proj_prio_a:
            color = "red"
        elif pid == c.proj_prio_b1 or pid == c.proj_prio_b2:
            color = "yellow"
        elif pid == c.proj_prio_c1 or pid == c.proj_prio_c2:
            color = "green"

        p = c.projects[pid]
        print(f"[{color}]\[{pid}:{p.timeframe.to_s()}] {p.title}[/{color}]")

    with collection() as c:
        def sorted_task_index(tid: str):
            assert tid in c.tasks
            t = c.tasks[tid]
            if t.timeframe is not None:
                return t.timeframe

            if t.project_id is not None:
                return c.projects[t.project_id].timeframe

            return -1

        sorted_task_ids = sorted(c.tasks, key=sorted_task_index)
        sorted_empty_projects = sorted([pid for pid, p in c.projects.items() if len(p.tasks) == 0], key=lambda pid: c.projects[pid].timeframe)
        print("--- Tasks --- ")
        for tid in sorted_task_ids:
            print_task(c, tid)

        print()
        print("--- Projects --- ")
        for pid in sorted_empty_projects:
            print_project(c, pid)


def add_project(c: Collection, id: str):
    print("Adding project")
    title = input("Title: ").strip()
    description = input("Description: ").strip()
    timeframe = Timeframe.from_str(input("Timeframe: ").strip())
    parent = None
    possible_parents = [pid for pid, p in c.projects.items() if p.timeframe > timeframe]
    if len(possible_parents) > 0:
        possible_parents.append("<create new>")
        use_parent = input("Set Parent? [Y/n]:").strip().lower()
        if len(use_parent) == 0 or use_parent == "y":
            parent = pick(possible_parents)
        else:
            assert use_parent == "n"

        if parent == "<create new>":
            new_id = input("Parent id: ").strip()
            add_project(c, new_id)
            parent = new_id

    assert id not in c.projects
    c.projects[id] = Project(
        tasks=set(),
        title=title,
        description=description,
        parents=set(),
        timeframe=timeframe
    )

    print("Added project")

    for tid, t in c.tasks.items():
        if t.project_id == id:
            c.projects[id].tasks.add(tid)
            print("Linked orphaned task")

def add_proj(args):
    with collection() as c:
        try:
            add_project(c, args.id)
        except KeyboardInterrupt:
            pass


def add(args):
    with collection() as c:
        id = str(uuid.uuid4())
        while id in c.tasks:
            id = str(uuid.uuid4())

        if args.parent is not None:
            assert args.parent in c.projects
            c.projects[args.parent].tasks.add(id)

        timeframe = None if args.timeframe is None else Timeframe.from_str(args.timeframe)

        c.tasks[id] = Task(title=args.title, 
                           description=args.description, 
                           project_id=args.parent,
                           timeframe=timeframe)


def create_parsers() -> ArgumentParser:
    parser = ArgumentParser("A file-based project manager")
    subparsers = parser.add_subparsers()

    add_parser = subparsers.add_parser("add", help="Create a new task")
    add_parser.add_argument("title", help="The task title")
    add_parser.add_argument("-d", "--description", help="The task description")
    add_parser.add_argument("-p", "--parent", help="The project for this task")
    add_parser.add_argument("-t", "--timeframe", help="The timeframe for this task")
    add_parser.set_defaults(func=add)

    add_parser = subparsers.add_parser("add-proj")
    add_parser.add_argument("id", help="The project id")
    add_parser.set_defaults(func=add_proj)

    show_parser = subparsers.add_parser("show")
    show_parser.add_argument("id", help="The project id", nargs="?")
    show_parser.set_defaults(func=show)

    return parser


def main():
    args = create_parsers().parse_args()

    func = None
    try:
        func = args.func
    except AttributeError:
        create_parsers().print_usage()
        exit(1)
    func(args)


if __name__ == '__main__':
    main()
