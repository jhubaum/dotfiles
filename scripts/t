#!/usr/bin/env -S uv run --script

# /// script
# dependencies = [
#   "pydantic",
#   "rich"
# ]
# ///

from argparse import ArgumentParser
from pathlib import Path
from pydantic import BaseModel, Field
from enum import IntEnum, auto
from typing import Optional, Protocol
import json
from contextlib import contextmanager
import subprocess
import uuid
import curses
from dataclasses import dataclass, field as DCField
from collections import defaultdict
import sys

from rich import print

CONTEXT = {
    "private": Path.home() / "notes/buckets",
    "work": Path.home() / "gtd"
}

METADATA_FILE = Path.home() / ".taskstate.json"

class Window:
    def __init__(self):
        self.screen = None

    def initialize(self):
        self.screen = curses.initscr()

        curses.noecho()
        curses.cbreak()

        try:
            curses.start_color()
            curses.use_default_colors()
        except:
            pass

        self.screen.keypad(1)

        curses.init_pair(1, curses.COLOR_RED, -1)
        curses.init_pair(2, curses.COLOR_YELLOW, -1)
        curses.init_pair(3, curses.COLOR_GREEN, -1)
        curses.init_pair(4, 8, -1)

    def reset(self):
        if self.screen is None:
            return

        self.screen.keypad(0)
        curses.echo()
        curses.nocbreak()
        curses.endwin()
        self.screen = None

    def run_terminal_app(self, *args: str, input: Optional[str]=None):
        self.reset()
        res = subprocess.run(*args, input=input, text=True, stdout=subprocess.PIPE)
        self.initialize()
        return res


@contextmanager
def window_manager():
    window = Window()
    window.initialize()
    try:
        yield window
    finally:
        window.reset()


def pick(options: list[str]) -> Optional[str]:
    res = subprocess.run("fzf", input="\n".join(options), stdout=subprocess.PIPE, text=True)
    try:
        res.check_returncode()
    except Exception:
        return None

    return res.stdout.strip()


TIMEFRAME_OPTIONS = ["d", "w", "m", "q", "y", "5y"]

class Timeframe(IntEnum):
    day = 0
    week = auto()
    month = auto()
    quarter = auto()
    year = auto()
    five_year = auto()

    @staticmethod
    def from_str(val: str) -> "Timeframe":
        return Timeframe(TIMEFRAME_OPTIONS.index(val))

    def to_s(self):
        return TIMEFRAME_OPTIONS[self.value]

class PriorityTable(BaseModel):
    a: Optional[str] = None
    b1: Optional[str] = None
    b2: Optional[str] = None
    c1: Optional[str] = None
    c2: Optional[str] = None


    def set_a(self, id: str):
        self.reset(id)
        self.a = id

    def set_b(self, id: str):
        self.reset(id)
        self.b2 = self.b1
        self.b1 = id

    def set_c(self, id: str):
        self.reset(id)
        self.c2 = self.c1
        self.c1 = id

    def reset(self, id: str):
        if self.a == id:
            self.a = None

        if self.b1 == id:
            self.b1 = self.b2
            self.b2 = None

        if self.b2 == id:
            self.b2 = None

        if self.c1 == id:
            self.c1 = self.c2
            self.c2 = None

        if self.c2 == id:
            self.c2 = None


class Task(BaseModel):
    title: str
    description: Optional[str] = None
    project_id: Optional[str] = None
    timeframe: Optional[Timeframe] = None


class Project(BaseModel):
    tasks: set[str]
    title: str
    parents: set[str]
    timeframe: Timeframe
    description: Optional[str] = None

    def delete(self, root: Path):
        (root / f"{id}.md").unlink(missing_ok=True)
        if (root / f"{id}").is_dir():
            (root / f"{id}").rmdir()


class Collection(BaseModel):
    tasks: dict[str, Task]
    projects: dict[str, Project]
    context: str = Field(exclude=True)

    # Acting on projects
    five_year_prios: PriorityTable = PriorityTable()
    yearly_prios: PriorityTable = PriorityTable()
    quarterly_prios: PriorityTable = PriorityTable()
    monthly_prios: PriorityTable = PriorityTable()
    weekly_prios: PriorityTable = PriorityTable()

    # Acting on tasks
    daily_prios: PriorityTable = PriorityTable()

    current_timeframe: Timeframe = Timeframe.five_year

    def current_prios(self):
        if self.current_timeframe == Timeframe.five_year:
            return self.five_year_prios

        if self.current_timeframe == Timeframe.year:
            return self.yearly_prios

        if self.current_timeframe == Timeframe.quarter:
            return self.quarterly_prios

        if self.current_timeframe == Timeframe.month:
            return self.monthly_prios

        if self.current_timeframe == Timeframe.week:
            return self.weekly_prios

        assert False

    def is_prio_a(self, pid: str):
        p = self.projects[pid]
        assert p.timeframe != Timeframe.day
        for tbl in [
            self.five_year_prios,
            self.yearly_prios,
            self.quarterly_prios,
            self.monthly_prios,
            self.weekly_prios
        ]:
            if tbl.a == pid:
                return True
        return False

    def is_prio_b(self, pid: str):
        p = self.projects[pid]
        assert p.timeframe != Timeframe.day
        for tbl in [
            self.five_year_prios,
            self.yearly_prios,
            self.quarterly_prios,
            self.monthly_prios,
            self.weekly_prios
        ]:
            if tbl.b1 == pid or tbl.b2 == pid:
                return True
        return False


    def is_prio_c(self, pid: str):
        p = self.projects[pid]
        assert p.timeframe != Timeframe.day
        for tbl in [
            self.five_year_prios,
            self.yearly_prios,
            self.quarterly_prios,
            self.monthly_prios,
            self.weekly_prios
        ]:
            if tbl.c1 == pid or tbl.c2 == pid:
                return True
        return False


    @staticmethod
    def load(context=None):
        if context is None:
            if METADATA_FILE.is_file():
                context = json.loads(METADATA_FILE.read_text())["current_context"]
            else:
                context = "private"

        path = CONTEXT[context]
        if not (path / "tasks.json").is_file():
            return Collection(tasks={}, projects={}, context=context)

        with (path / "tasks.json").open("r") as f:
            collection = Collection(**json.load(f), context=context)
            collection.validate()
            return collection

    def save(self):
        with (CONTEXT[self.context] / "tasks.json").open("w") as f:
            f.write(self.model_dump_json(indent=4))

        with METADATA_FILE.open("w") as f:
            json.dump(dict(current_context=self.context), f, ensure_ascii=False, indent=4)

    def validate(self):
        for task in self.tasks.values():
            assert task.project_id is None or task.project_id in self.projects

        for project in self.projects.values():
            for task in project.tasks:
                assert task in self.tasks
                assert self.tasks[task].timeframe is None or self.tasks[task].timeframe <= project.timeframe

            for parent in project.parents:
                assert parent in self.projects
                assert self.projects[parent].timeframe > project.timeframe


@contextmanager
def collection():
    collection = Collection.load()
    yield collection
    collection.save()


def review(args):
    """
    - review timeframe
    - for each open element say "delete", "defer", "complete"
    - view notes of previous time frame
    - add note
    """

    pass


def plan(args):
    """
    - plan timeframe
    - add new projects
    - set priority
    """
    pass


def show(args):
    """
    - view current projects as tree-view
    """

    def print_task(c: Collection, tid: str):
        t = c.tasks[tid]
        timeframe = None
        if t.timeframe is not None:
            timeframe = t.timeframe.to_s()
        elif t.project_id is not None:
            timeframe = c.projects[t.project_id].timeframe.to_s()

        pid = t.project_id or "orphaned"
        if timeframe is not None:
            timeframe = ":" + timeframe

        color = "bright_black"
        if tid == c.daily_prios.a:
            color = "red"
        elif tid == c.daily_prios.b1 or tid == c.daily_prios.b2:
            color = "yellow"
        elif tid == c.daily_prios.c1 or tid == c.daily_prios.c2:
            color = "green"

        print(f"[{color}]\[{pid}{timeframe or ''}] {t.title}[/{color}]")

    def print_project(c: Collection, pid: str):
        color = "bright_black"
        if c.is_prio_a(pid):
            color = "red"
        elif c.is_prio_b(pid):
            color = "yellow"
        elif c.is_prio_c(pid):
            color = "green"

        p = c.projects[pid]
        print(f"[{color}]\[{pid}:{p.timeframe.to_s()}] {p.title}[/{color}]")

    with collection() as c:
        def sorted_task_index(tid: str):
            assert tid in c.tasks
            t = c.tasks[tid]
            if t.timeframe is not None:
                return t.timeframe

            if t.project_id is not None:
                return c.projects[t.project_id].timeframe

            return -1

        sorted_task_ids = sorted(c.tasks, key=sorted_task_index)
        sorted_empty_projects = sorted(c.projects, key=lambda pid: c.projects[pid].timeframe)
        print("--- Tasks --- ")
        for tid in sorted_task_ids:
            print_task(c, tid)

        print()
        print("--- Projects --- ")
        for pid in sorted_empty_projects:
            print_project(c, pid)


def add_project(c: Collection, id: str):
    print("Adding project")
    title = input("Title: ").strip()
    description = input("Description: ").strip()
    timeframe = Timeframe.from_str(input("Timeframe: ").strip())
    parent = None
    possible_parents = [pid for pid, p in c.projects.items() if p.timeframe > timeframe]
    if len(possible_parents) > 0:
        possible_parents.append("<create new>")
        use_parent = input("Set Parent? [Y/n]:").strip().lower()
        if len(use_parent) == 0 or use_parent == "y":
            parent = pick(possible_parents)
        else:
            assert use_parent == "n"

        if parent == "<create new>":
            new_id = input("Parent id: ").strip()
            add_project(c, new_id)
            parent = new_id

    assert id not in c.projects
    c.projects[id] = Project(
        tasks=set(),
        title=title,
        description=description,
        parents=set(),
        timeframe=timeframe
    )

    print("Added project")

    for tid, t in c.tasks.items():
        if t.project_id == id:
            c.projects[id].tasks.add(tid)
            print("Linked orphaned task")

def add_proj(args):
    with collection() as c:
        try:
            add_project(c, args.id)
        except KeyboardInterrupt:
            pass


def add(args):
    with collection() as c:
        id = str(uuid.uuid4())
        while id in c.tasks:
            id = str(uuid.uuid4())

        if args.parent is not None:
            assert args.parent in c.projects
            c.projects[args.parent].tasks.add(id)

        timeframe = None if args.timeframe is None else Timeframe.from_str(args.timeframe)

        c.tasks[id] = Task(title=args.title, 
                           description=args.description, 
                           project_id=args.parent,
                           timeframe=timeframe)


def create_parsers() -> ArgumentParser:
    parser = ArgumentParser("A file-based project manager")
    subparsers = parser.add_subparsers()

    add_parser = subparsers.add_parser("add", help="Create a new task")
    add_parser.add_argument("title", help="The task title")
    add_parser.add_argument("-d", "--description", help="The task description")
    add_parser.add_argument("-p", "--parent", help="The project for this task")
    add_parser.add_argument("-t", "--timeframe", help="The timeframe for this task")
    add_parser.set_defaults(func=add)

    add_parser = subparsers.add_parser("add-proj")
    add_parser.add_argument("id", help="The project id")
    add_parser.set_defaults(func=add_proj)

    show_parser = subparsers.add_parser("show")
    show_parser.add_argument("id", help="The project id", nargs="?")
    show_parser.set_defaults(func=show)

    return parser

@dataclass
class RenderElement:
    content: str
    attr: int = 0

def render_rows(w: Window, index: int, labels: list[str], rows: list[list[RenderElement]], width: int):
    assert len(labels) == len(rows)

    label_length = max(len(label) for label in labels)

    col_widths = []

    for row in rows:
        for i, elem in enumerate(row):
            if len(col_widths) <= i:
                col_widths.append(len(elem.content))
            else:
                col_widths[i] = max(col_widths[i], len(elem.content))

    for i, label in enumerate(labels):
        w.screen.addstr(i, 0, label)

    if len(col_widths) == 0:
        return

    minimal_width = col_widths[index] + label_length + 1
    while index > 0 and minimal_width + col_widths[index-1] + 1 < width:
        index -= 1
        minimal_width += col_widths[index] + 1


    for i, row in enumerate(rows):
        start = label_length + 1

        if index != 0:
            w.screen.addstr(i, start, "... ")
            start += 4

        for j, elem in enumerate(row[index:]):
            remaining_space = width - start

            if remaining_space < 3:
                if remaining_space > 0:
                    w.screen.addstr(i, start, "." * remaining_space)
                break

            if remaining_space < len(elem.content):
                elem.content = elem.content[0:remaining_space-3] + "..."

            w.screen.addstr(i, start, elem.content, elem.attr)
            start += col_widths[j+index] + 1


@dataclass
class ProjectPreviewTable:
    project_id_rows: list[list[str]] 
    selected_x: int = 0
    selected_y: int = 0

    @staticmethod
    def from_collection(c: Collection):
        @dataclass
        class ProjectsRow:
            prio_a: Optional[str] = None
            prio_bs: list[str] = DCField(default_factory=list)
            prio_cs: list[str] = DCField(default_factory=list)
            other: list[str] = DCField(default_factory=list)

            def insert(self, pid: str, c: Collection):
                if c.is_prio_a(pid):
                    self.prio_a = pid
                elif c.is_prio_b(pid):
                    self.prio_bs.append(pid)
                elif c.is_prio_c(pid):
                    self.prio_cs.append(pid)
                else:
                    self.other.append(pid)

            def __iter__(self):
                if self.prio_a is not None:
                    yield self.prio_a

                yield from self.prio_bs
                yield from self.prio_cs
                yield from self.other


        rows = defaultdict(ProjectsRow)
        for pid, p in c.projects.items():
            rows[p.timeframe].insert(pid, c)

        return ProjectPreviewTable(project_id_rows=[ 
            list(rows[Timeframe.five_year]),
            list(rows[Timeframe.year]),
            list(rows[Timeframe.quarter]),
            list(rows[Timeframe.month]),
            list(rows[Timeframe.week]),
            list(rows[Timeframe.day]),
        ])

    def render(self, w, c, width):
        labels = [
            "Next Five Years:",
            "This Year:",
            "This Quarter:",
            "This Month:",
            "This Week:",
            "Today:"
        ]

        rows = []
        for i, l in enumerate(labels):
            row = []
            selected_x = min(self.selected_x, len(self.project_id_rows[i])-1)
            for j, pid in enumerate(self.project_id_rows[i]):
                attr = None
                if c.is_prio_a(pid):
                    attr = curses.color_pair(1)
                elif c.is_prio_b(pid):
                    attr = curses.color_pair(2)
                elif c.is_prio_c(pid):
                    attr = curses.color_pair(3)

                if self.selected_y == i and selected_x == j:
                    if attr is None:
                        attr = 0
                    attr |= curses.A_REVERSE

                if attr is None:
                    attr = curses.color_pair(4)
                row.append(RenderElement(content=c.projects[pid].title, attr=attr))
            rows.append(row)
        render_rows(w, self.selected_x, labels, rows, width)

    def width(self):
        return max(len(row) for row in self.project_id_rows)

    def height(self):
        return len(self.project_id_rows)


    def selected(self):
        if len(self.project_id_rows[self.selected_y]) == 0:
            return None
        return self.project_id_rows[self.selected_y][min(self.selected_x, len(self.project_id_rows[self.selected_y])-1)]


def render_project_preview(w: Window, c: Collection, pid: str, width):
    scr = w.screen.subwin(curses.LINES-3, width, 0, curses.COLS - width)
    scr.box()

    p = c.projects[pid]
    h = 1

    def add_str(string, attr=0):
        nonlocal h
        scr.addstr(h, 1, string, attr);
        h += 1

    add_str(p.title, curses.A_BOLD)
    if p.description is not None and len(p.description) > 0:
        h += 1
        add_str(p.description)

    child_projects = set()
    for cid, child in c.projects.items():
        # TODO: Do this recursively to detect all child projects
        if pid in child.parents:
            child_projects.add(cid)

    if len(child_projects) > 0:
        h += 1
        add_str("Projects")
        for cid in child_projects:
            child = c.projects[cid]
            add_str(f"- [{cid}:{child.timeframe.to_s()}] {child.title}")

    if len(p.tasks) > 0:
        h += 1
        add_str("Tasks")
        for tid in p.tasks:
            add_str(f"- [ ] {c.tasks[tid].title}")


class WindowMode(Protocol):
    def render_main_window(self, w: Window, c: Collection):
        pass

    def handle_input(self, ch: str, c: Collection) -> Optional["WindowMode"]:
        pass

    def available_commands(self, c: Collection):
        yield from ()


class PlanningMode(WindowMode):
    def __init__(self, c: Collection):
        self.index = 0
        self.project_ids = [
            pid for pid, p in c.projects.items() if p.timeframe == c.current_timeframe
        ]
        self.selecting_priority = False

    def render_main_window(self, w: Window, c: Collection):
        for i, pid in enumerate(self.project_ids):
            attr = 0
            if c.is_prio_a(pid):
                attr = curses.color_pair(1)
            elif c.is_prio_b(pid):
                attr = curses.color_pair(2)
            elif c.is_prio_c(pid):
                attr = curses.color_pair(3)

            if i == self.index:
                attr = attr | curses.A_REVERSE
            w.screen.addstr(i, 0, f"{pid}: {c.projects[pid].title}", attr)
        if len(self.project_ids) > 0:
            render_project_preview(w, c, self.project_ids[self.index], curses.COLS // 2)

    def handle_input(self, ch: str, c: Collection) -> Optional[WindowMode]:
        if self.selecting_priority:
            if ch.lower() == "a":
                c.current_prios().set_a(self.project_ids[self.index])

            if ch.lower() == "b":
                c.current_prios().set_b(self.project_ids[self.index])

            if ch.lower() == "c":
                c.current_prios().set_c(self.project_ids[self.index])

            if ch.lower() == "r":
                c.current_prios().reset(self.project_ids[self.index])

            self.selecting_priority = False
            return None

        if ch.lower() == "p":
            self.selecting_priority = True
            return None

        if ch == "KEY_UP" or ch.lower() == "k":
            self.index -= 1

        if ch == "KEY_DOWN" or ch.lower() == "j":
            self.index += 1

        if self.index < 0:
            self.index = 0
        if self.index >= len(self.project_ids):
            self.index = len(self.project_ids) - 1

    def available_commands(self, c: Collection):
        if self.selecting_priority:
            yield "a", "A"
            yield "b", "B"
            yield "c", "C"
            yield "r", "reset"
            return

        yield "c", "Create new project"
        yield "e", "Edit project"
        yield "d", "Delete project"
        yield "p", "Set priority"
        yield "f", "Finish Plan"


class MainWindow(WindowMode):
    def __init__(self, c: Collection):
        self.table = ProjectPreviewTable.from_collection(c)
        self.show_project_overview = False

    def render_main_window(self, w: Window, c: Collection):
        width = curses.COLS
        if self.show_project_overview:
            width = curses.COLS // 2
        self.table.render(w, c, width)
        pid = self.table.selected()
        if pid is not None and self.show_project_overview:
            render_project_preview(w, c, pid, width)

    def handle_input(self, ch: str, c: Collection) -> Optional[WindowMode]:
        if ch.lower() == "r":
            pass
        elif ch.lower() == "p":
            return PlanningMode(c)

        if ch == "\t":
            self.show_project_overview = not self.show_project_overview

        if ch == "KEY_RIGHT" or ch.lower() == "l":
            self.table.selected_x += 1

        if ch == "KEY_LEFT" or ch.lower() == "h":
            self.table.selected_x -= 1

        if ch == "KEY_UP" or ch.lower() == "k":
            self.table.selected_y -= 1

        if ch == "KEY_DOWN" or ch.lower() == "j":
            self.table.selected_y += 1

        self.table.selected_y = max(0, min(self.table.selected_y, self.table.height()))
        self.table.selected_x = max(0, min(self.table.selected_x, len(self.table.project_id_rows[self.table.selected_y])))

        return None

    def available_commands(self, c):
        yield "\t", "Toggle project preview"
        if c.current_timeframe != Timeframe.five_year:
            yield "r", f"Review {c.current_timeframe.to_s()}"

        if c.current_timeframe != Timeframe.day:
            yield "p", f"Plan {c.current_timeframe.to_s()}"


def win_main(w: Window):
    collection = Collection.load()
    state = MainWindow(collection)

    SPECIAL_KEYS = { "\t": "TAB" }

    while True:
        w.screen.clear()
        state.render_main_window(w, collection)

        commands = { 
            "q": "Quit"
        }

        # TODO: Is there a better way to do this check?
        if isinstance(state, MainWindow):
            commands["c"] = "Switch Context"

        for cmd, name in state.available_commands(collection):
            assert cmd not in commands
            commands[cmd] = name

        command_bar_str = f"[{collection.context}]  "
        for key, name in commands.items():
            if key in SPECIAL_KEYS:
                key = f"<{SPECIAL_KEYS[key]}>"
            else:
                key = f"({key})"
            command_bar_str += f"{key} {name}  "

        w.screen.subwin(curses.LINES-3, 0).box()
        w.screen.addstr(curses.LINES-2, 1, command_bar_str)
        w.screen.refresh()

        ch = w.screen.getkey()

        w.screen.refresh()
        if ch.lower() == "q":
            break
        if ch.lower() == "c":
            if collection.context == "private":
                new_context = "work"
            else:
                new_context = "private"
            collection.save()
            collection = Collection.load(new_context)
            state = MainWindow(collection)
            continue

        new_state = state.handle_input(ch, collection)
        if new_state is not None:
            state = new_state


    collection.save()


def main():
    args = create_parsers().parse_args()

    func = None
    try:
        func = args.func
    except AttributeError:
        with window_manager() as w:
            win_main(w)
        return
    func(args)

if __name__ == '__main__':
    main()
